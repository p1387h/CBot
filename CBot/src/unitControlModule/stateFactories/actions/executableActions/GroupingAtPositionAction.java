package unitControlModule.stateFactories.actions.executableActions;

import bwapi.Color;
import bwapi.Pair;
import bwapi.Position;
import bwapiMath.Point;
import bwapiMath.Polygon;
import bwapiMath.Vector;
import bwta.Region;
import javaGOAP.GoapState;
import javaGOAP.IGoapUnit;
import unitControlModule.stateFactories.actions.executableActions.steering.SteeringFactory;
import unitControlModule.unitWrappers.PlayerUnit;

/**
 * GroupingAtPositionAction.java --- A general grouping Action with which a Unit
 * can group together at a certain spot with other allies (One uniform grouping
 * Spot!). <br>
 * <br>
 * <b>Note:</b><br>
 * The grouping performed by this Action is <b>actual</b> grouping of Units (!),
 * not a general unified execution of Actions. <br>
 * <br>
 * This Action is executed exactly once for each Unit whose
 * "groupingNeeded"-flag is set. Once a certain Unit limit is reached, the
 * Action is "finished" and all Units currently waiting at the assigned spots
 * are released (Also their flags are reset). This Action is executed globally,
 * which means that the assignable Units can be anywhere on the map. This
 * ensures that especially in the beginning of the game (All) Units meet at a
 * certain defined spot instead of rushing blindly into the enemy lines. This
 * ensures a level of consistency and serves as a defensive mechanism as well
 * (I.e. Zerg rushes). The spot that the Units are gathering is set by any
 * extending subclass.
 * 
 * @author P H - 15.12.2017
 *
 */
public abstract class GroupingAtPositionAction extends BaseAction {

	/**
	 * Private Class used for validating the Positions generated by the retreat
	 * group cluster.
	 */
	private class PositionValidator implements RetreatPositionValidator {

		// The own generated grouping Position of the leader. Used for verifying
		// that the other Positions are in the same Region.
		private Position groupingPosition;

		public PositionValidator(Position groupingPosition) {
			this.groupingPosition = groupingPosition;
		}

		@Override
		public boolean validatePosition(Point position) {
			Position checkedPosition = new Position(position.getX(), position.getY());
			Pair<Region, Polygon> boundaries = BaseAction.findBoundariesPositionIsIn(checkedPosition);
			boolean positionBlocked = SteeringFactory.isEndPositionBlockedByNeutralOrBuilding(checkedPosition);

			return boundaries != null && boundaries.equals(BaseAction.findBoundariesPositionIsIn(this.groupingPosition))
					&& !positionBlocked;
		}

	}

	// Generated Position by this specific Unit where all others meet.
	private Position groupingPosition = null;
	// The number of Units after which the group will be considered "full" and
	// therefore be destroyed. This causes all Units currently inside the group
	// to attack / perform other Actions together.
	// Must be smaller than the maxGroupSize value since that value manages the
	// upper level grouping of Actions as a whole.
	// -> After reaching this size, all Actions of each member are reset.
	private int maxGroupSizeUntilConsideredFull = 9;
	// Flag indicating if the rest of the group was reset. This is needed due to
	// the leader not being able to remove itself from the group in the
	// iteration all other members are performing the Action and therefore being
	// removed from it. This has to be done one iteration later.
	private boolean groupReset = false;

	// Group related stuff.
	private RetreatPositionCluster groupingPositionCluster;
	private int distanceBetweenUnits = 48;
	private int matrixTurnAngleXDEG = 0;
	private int matrixTurnAngleYDEG = 90;
	// Larger than the "filled" group's maximum since this prevents other
	// Actions from being grouped into separate execution cycles. This way only
	// a single group of Units will execute this Action together.
	private int maxGroupSize = 500;
	private int maxLeaderTileDistance = 1000;

	/**
	 * @param target
	 *            type: Null (Is indirectly defined by subclasses)
	 */
	public GroupingAtPositionAction(Object target) {
		super(target);

		this.addEffect(new GoapState(0, "grouped", true));
		this.addPrecondition(new GoapState(0, "canMove", true));
		this.addPrecondition(new GoapState(0, "grouped", false));
		this.addPrecondition(new GoapState(0, "needsGrouping", true));
	}

	// -------------------- Functions

	@Override
	protected boolean performSpecificAction(IGoapUnit goapUnit) {
		PlayerUnit playerUnit = (PlayerUnit) goapUnit;
		int currentTotalGroupSize = playerUnit.getInformationStorage().getBaseActionSharedInformation()
				.getGroupActionManager().getGroupSize(goapUnit);
		boolean success = true;

		if (this.groupingPosition == null) {
			this.groupingPosition = this.generateGroupingPosition(playerUnit);

			// Generate the PositionValidator for the applied grouping Position
			// and the associated retreat cluster.
			PositionValidator validator = new PositionValidator(this.groupingPosition);
			this.groupingPositionCluster = new RetreatPositionCluster((RetreatUnit) this.currentlyExecutingUnit,
					new Point(this.groupingPosition), this.distanceBetweenUnits, this.matrixTurnAngleXDEG,
					this.matrixTurnAngleYDEG, validator);
		}

		// TODO: DEBUG INFO
		// Position to which the Unit moves to
		if (this.groupingPosition != null) {
			// Slightly changed due to the Unit being directly on top of the
			// Position (When reached).
			(new Vector(playerUnit.getUnit().getPosition(),
					new Position(this.groupingPosition.getX() - 1, this.groupingPosition.getY() - 1)))
							.display(new Color(255, 255, 0));
			(new Point(this.groupingPosition)).display(new Color(0, 255, 0));
		}

		// Prevent errors by checking the retreat Position first.
		if (this.groupingPosition != null) {
			success &= this.groupingPosition != null && playerUnit.getUnit().move(this.groupingPosition);
		}

		// Make sure to set the reset Flag for reseting all other members of the
		// group if a certain number of Units are part of this group. Setting
		// the flag causes the whole group to be discarded / destroyed.
		if (currentTotalGroupSize >= this.maxGroupSizeUntilConsideredFull) {
			this.groupReset = true;
		}

		return this.groupingPosition != null && success;
	}

	/**
	 * Function used for generating a Position at which a Unit groups up with
	 * other Units. Is called when a new grouping Position is needed.
	 * 
	 * @param goapUnit
	 *            the Unit that will perform the Action.
	 * @return a Position to which the performing Unit can move to in order to
	 *         group up with other Units.
	 */
	protected abstract Position generateGroupingPosition(IGoapUnit goapUnit);

	@Override
	protected void resetSpecific() {
		this.target = new Object();

		this.groupingPosition = null;
		this.groupingPositionCluster = null;
		this.groupReset = false;
	}

	@Override
	protected boolean checkProceduralPrecondition(IGoapUnit goapUnit) {
		PlayerUnit playerUnit = (PlayerUnit) goapUnit;

		return playerUnit.getAttackableEnemyUnitToReactTo() == null && playerUnit.needsGrouping();
	}

	@Override
	protected float generateBaseCost(IGoapUnit goapUnit) {
		return 0;
	}

	@Override
	protected float generateCostRelativeToTarget(IGoapUnit goapUnit) {
		return 0;
	}

	@Override
	protected boolean isDone(IGoapUnit goapUnit) {
		PlayerUnit playerUnit = (PlayerUnit) goapUnit;

		// Only applies to the group-leader, since he is not affected by the
		// group-Action below. Is reached one iteration after the members were
		// reset.
		if (this.groupReset) {
			playerUnit.setNeedsGrouping(false);
		}

		return playerUnit.getAttackableEnemyUnitToReactTo() != null || this.groupReset || !playerUnit.needsGrouping();
	}

	@Override
	protected boolean isInRange(IGoapUnit goapUnit) {
		return false;
	}

	@Override
	protected boolean requiresInRange(IGoapUnit goapUnit) {
		return false;
	}

	// -------------------- Group

	@Override
	public boolean canPerformGrouped() {
		return true;
	}

	@Override
	public boolean performGrouped(IGoapUnit groupLeader, IGoapUnit groupMember) {
		PlayerUnit playerUnit = (PlayerUnit) groupMember;

		// Add the Unit to the cluster if it was missing before.
		if (!this.groupingPositionCluster.containsRetreatUnit(playerUnit)) {
			this.groupingPositionCluster.addUnit(playerUnit);
		}

		// Move the Unit to it's assigned location.
		Point position = this.groupingPositionCluster.getAssignedPosition(playerUnit);
		boolean success = playerUnit.getUnit().move(new Position(position.getX(), position.getY()));

		// The size of the group must not exceed a certain amount of Units. If a
		// threshold is met, all Units are free to go / attack the enemy.
		// Members are reset one iteration before the leader.
		if (this.groupReset) {
			playerUnit.manuallyResetActions();
			playerUnit.setNeedsGrouping(false);

			success = true;
		}

		// TODO: DEBUG INFO POSITION
		this.groupingPositionCluster.display();

		return success;
	}

	@Override
	public int defineMaxGroupSize() {
		return this.maxGroupSize;
	}

	@Override
	public int defineMaxLeaderTileDistance() {
		return this.maxLeaderTileDistance;
	}

}
